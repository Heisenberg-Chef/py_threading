#   python多线程内置库，threading(多线程)
```
进程：
    优点：同时利用多个CPU，能够同时进行多个操作
    缺点：消耗资源，需要重新开辟内存空间
    
线程：
    优点：共享内存，IO操作时候，创造并发操作
    缺点：抢占资源

进程不是越多越好，CPU格式=进程个数

线程也不是越多越好，上下文进行切换耗费时间的

计算机执行任务时候的最小单元：线程

IO操作利用CPU

GIL，全局解释器锁

```
+   总结一下就是：
    +   IO密集型（不费CPU）：多线程
    +   计算密集型（耗费CPU）：多进程
    +   使用多线程或者多进程都是用来提升效率
+ python的线程操作在旧版本中使用的是thread模块，在py2、py3中引入threading模块，同事thread模块在python3中改名了threading老模块改成了_thread，推荐使用threading。模块中包含了关于线程操作的内容：常用线程函数，线程对象，锁对象，递归锁对象，时间对象，条件变量对象，信号量对象，定时器对象，栅栏对象。
####    with语法：
+   这个模块中所有带有acquire()和release()方法的对象，都可以使用with语句，当进入with语句块时，acquire()方法呗自动调用，当离开with语句块的时候，release()语句呗自动调用，包括Lock,RLock,Condition,Semaphore.
####    threading函数：
+   通常情况先，python解释器启动一个集成自threading.Thread的threading.__MainThread线程对象作为主线程，所以涉及到threading.Thread的方法和函数时通常都算上这个主线程，比如启动程序时打印threading.active_count()的结果就已经是1了。
    +   threading.active_count():返回当前存货的threading.Thread的线程对象数量，等同于len(threading.enumerate())
    +   threading.current_thread():返回此函数的调用者控制的threading.Thread线程对象，如果当前调用者控制的线程不是通过threading.Thread创建的，则返回一个功能受限的虚拟线程对象。
    +   threading。get_ident()：返回当前线程的线程标识符，当一个线程退出时候，它的线程标识符可能被之后的线程所复用。
    +   threading.enumerate():返回当前存在的对象的列表。是一个枚举形态，可以使用迭代器进行迭代
    +   threading.main_thread():返回主线程对象，通常情况下，就是程序启动时候python解释器创建的threading._MainThread线程对象。
    +   threading.stack_size([size]):返回创建线程时候使用的堆栈大小，也可以使用可以选参数size指定之后创建线程的堆栈大小，size可以是0或者一个不大于32KiB的正整数，如果参数没有指定，则默认是0.如果系统不支持改变堆栈大小则会引发异常：RuntimeError错误，如果堆栈大小不合法则会引发ValueError异常。
### threading常量
+   threading.TIMEOUT_MAX：指定阻塞函数（例如Lock.acquire(),RLock.acquire(),Condition.wait())中参数timeout最大值，在给这些则色函数传参时如果超过了这个指定的最大值则会抛出OverflowError。
### threading.Thread线程对象
+   线程对象目前还没有优先级和线程组的功能，而且创建的线程也不能被销毁、 停止、暂停、恢复、中断。
+   **守护线程**：只有所有守护线程线程都结束，整个Python程序才会退出，但并不是说Python程序会等待守护线程运行完毕，相反，当程序退出时，如果还有守护进程在运行，程序也会强制停止所有的守护进程，当所有守护线程都结束之后，程序才会真正的退出。就可以修改daemon属性或者初始化线程时指定daemon参数来指定某个线程为守护线程。
+   **非守护线程**：一般创建的线程默认都是非守护线程，包括主线程也是，即在python退出时候，如果还有非守护线程在运行，程序会等到所有守护进程结束后，非守护进程才会关闭。
```
threading.Thread(group=None,target=None,name=None.args=(),kwargs={},*,daemon=None)
```
+   如果这个类被重写，请确保在重写的初始化方法中做认识事情之前先调用threading.Thread的__init__方法。
    +   group：应该设为None，这个参数是实现ThreadGroup而保留，现在还没有实装。
    +   target：在run方法中调用课调用的对象开启线程的可调用对象，比如函数方法。
    +   name：线程的名称，默认为‘Thread-N’的命名规则，N为较小的10进制数字
    +   args：在参数target中传入课调用的参数元祖默认为空的元祖()。
    +   kwargs：在参数target传入字典，默认是{}。
    +   daemon:默认是None，标记守护模式
+   start():开启线程活动，它将使得run()方法在一个独立的控制线程中被调用，只可以调用一次，如果调用多次则会发生RuntimeError，start()就是内置方法，可以使用Thread类型直接加载外部定义的一个函数进行线程的调用，在类中target传入func的标记，args传入参数。之后调用start()方法就可以开启线程
+   run():此方法代表线程活动，是使用Thread类进行重载类实行多线程的调用，run()方法时在类的内部进行调用，在实例化之后可以使用重载类直接start()进行使用，不需要在target传入函数名字了。默认的调用run()的内部函数。
+   join(timeout=None)：让当前调用者线程（即开启线程的线程，一般就是主线程）等待，知道线程结束（无论他是什么原因结束的），timeout参数是以秒为单位的浮点数，用于设置操作超时的时间，返回值为None，如果想要判断线程是否超时，只能通过线程的is_alive方法来判断。join方法可以被调用多次。timeout是以秒为单位的浮点数，是用来记录线程是否超时的。warning：如果在自己的线程中调用自己的joinb，或者在一个线程还没有开始之前就调用join都会报错，runtimeerror
    +   join用途在于，如果主线程在守护进程之前就消灭了，那么守护进程也会消失，所以配合daemon程序使用，join()守护进程
+   name:线程字符串名字没有意义
+   ident:线程标识符，如果该线程没有启动，那么它的名字是None。ident是一个非零整数。如同threading.get_ident()一样，线程结束之后，它的ident也可能会被别人占用。
+   is_alive()：线程是否存活，返回True或者False，在线程的run()运行之后直到run()结束，该方法返回True。
+   daemon：表示该线程是否是守护进程。设置守护进程也可以使用初始化的实例对象.setDaemon(True)的内置方法。

####    锁对象：threading.Lock
+   threading.Lock是直接通过_thread模块拓展实现的。当锁在被锁定时，它并不属于某一个特定的线程。
    +   锁只有'锁定'和'非锁'两种状态，当锁被创建的时候是属于非锁定。
    +   acquire(blocking=True,timeout=-1):获取锁，并将锁定的状态改为‘锁定’，当一个线程获得锁时，会阻塞其他尝试获取锁的线程，直到这个锁被释放掉。timeout默认为-1即将无线锁定直到获得锁，如果设为其他的值的，就是秒数。当blocking为False时，timeout参数被忽略，就是没有获得锁，也不进行阻塞。
    +   realease()释放一个锁，并将其状态改为非锁定，任何线程都可以释放锁，不只是获得锁的线程（因为锁并不是属于任何一个线程的）。release()方法只能在锁处于'锁定状态时候调用，如果在非锁定的时候调用则会报错RuntimeError'

#### 递归锁对象：threading.RLock
+   递归锁和普通锁的差别在于假如"所属线程"和"递归等级"的概念，释放锁必须获取的线程进行释放，同时,同一个线程在释放之前再次获取锁将不会阻塞当前线程，知识在所的递归登记上加了1（获得时初始递归等级为1）
+   **使用普通锁的时候可能会造成死锁现象，可以考虑递归锁来解决问题
+   acquire():与普通锁的不同之处在于：当使用默认值，如果这个线程递归等级+1，线程获得锁时候，该锁的递归等级为1，当多个线程被阻塞时，只有一个线程在锁被释放时获得锁，这种情况下，acquire()是没有返回值的。
+   release()：没有返回值，调用一次则递归等级-1，递归等级为0时候表示被释放，其他线程可以获取锁了，可能在一个线程中调用了多次acquire()，导致锁的递归等级大于1，那么需要调用对应次数的release()来完全释放锁，并将它的递归等级减到0，其他的线程才能获得锁，**不然就一直被阻塞
####    条件变量对象:threading.Condition
+   它的wait()方法释放锁，并阻塞程序知道其他线程调用notify()或者notify_all()方法唤醒，然后wait()方法重新获得锁，这个方法可以定义超时时间，它的notify方法唤醒一个正在等待的线程，notify_all()则是唤醒所有正在等待的线程。notify()或者noftify_all()并不会释放锁，所以被唤醒的线程并不会立即从它们wait()方法中返回并执行，只有在调用notify()或者notify_all()方法的线程放弃了锁的所有权才会返回对应的线程并执行，即先通知再释放锁。
+   threading.Condition(lock=None)：一个条件变量对象允许一个或者多个线程等待，直到另一个线程通知。lock参数必须是一个Lock对象或者Rlock对象，并且会作为底层锁使用，默认使用Rlock
    +   acquire(*args)：请求底层锁。
    +   release()释放锁
    +   wait(timeout=None)释放锁，等待直到被通知，或者发生超时时间，如果线程在调用此方法本身没有锁，则会报错，这个方法释放底层锁，然后阻塞线程，知道另一个线程中的同一个条件变量notify()或者notify_all()唤醒，或者超时事件发生，一旦被唤醒或者超时，则会重新去获取锁，timeout参数为浮点类型的秒数，在RLock中使用一次release方法，则并不能释放锁，因为锁可能被acquire()多次，但是条件变量对象中，它调用了Rlock内部的方法。一次就释放，重置等级。、
    +   wait_for(predicate,timeout):与wait方法相似，等待，直到条件计算为True，返回最后一次的predicate的返回值。predicate参数为一个返回值为布尔值的可调用对象。调用此方法的时候会先调用predicate对象，如果返回的就是True，则不会释放锁，直接往后执行。另一个线程通知后，在它释放锁时，才会触发wait_for方法等待事件，这时如果predicate结果为True，则尝试获取锁，获取成功后则继续往后执行，如果为False，则会一直阻塞下去。此方法如果忽略timeout参数，就相当于：while not predicate(): condition_lock.wait()。
    +   notify(n=1)：唤醒一个等待这个条件的线程，如果调用这个方法的线程在没有获得锁的情况下调用这个方法，会报RuntimeError错误。默认唤醒一个线程，可以通过参数n设置唤醒n个正在等待这个条件变量的线程，如果没有线程在等待，调用这个方法不会发生任何事。如果等待的线程中正好有n个线程，那么这个方法可以准确的唤醒这n个线程，但是等待的线程超过指定的n个，有时候可能会唤醒超过n个的线程，所以依赖参数n是不安全的行为。
    +   notify_all()：唤醒所有等待这个条件的线程。这个方法与notify()不同之处在于它唤醒所有线程，而不是特定n个。
####    信号量对象：threading.Semaphore
+   一个信号量管理一个内部计数器，acquire()方法会减少计数器，release()方法则增加计数器，如果发现计数器为0则阻塞线程，直到release()方法使其增加。
+   threading.Semaphore(value=1):value参数默认值是1，如果小于0会异常，信号量对象管理一个原子性的计数器，代表release()方法调用的次数减去
+   acquire(blocking=True, timeout=None)：默认情况下，在进入时，如果计数器大于0，则减1并返回True，如果等于0，则阻塞直到使用release()方法唤醒，然后减1并返回True。被唤醒的线程顺序是不确定的。如果blocking设置为False，调用这个方法将不会发生阻塞。timeout用于设置超时的时间，在timeout秒的时间内没有获取到信号量，则返回False，否则返回True。
+   release()：释放一个信号量，将内部计数器增加1。当计数器的值为0，且有其他线程正在等待它大于0时，唤醒这个线程。
####    事件对象:threading.Event
+   一个时间对象管理一个内部标志，默认初始值False，set()方法可将它设置为True，clear()方法可将它设置为False,wait()方法将线程阻塞知道内部标志位True
    +   is_set():当内部为True返回True
    +   set():设置内部标志位True,此时所有等待中的线程将被唤醒，调用wait()方法的线程不会被阻塞
    +   clear()：内部为False。所有调用wait()方法将被阻塞，直到调用直到set()调用为TRUE位置
    +   wait(timeout)：阻塞线程直到内部标志位True，或者发生超时时间，如果调用时内部标志是True，那么不会被阻塞，否则将被阻塞，timeout为浮点类型参数
####    定时器对象：threading.Timer
+   表示一个操作需要在一定时间之后执行，相当于一个定时器，Timer类是threading.Thread的子类，所以它可以像一个自定义线程一样工作，和线程一样，可以通过start()方法启动定时器，定时器结束之后（线程开启之前）可以使用cancel()的停止计时器。计时器等待的时间可能与用户设置的时间不完全一样=。
+   threading.Timer(interval,function,args=None,kwargs=None)
    +   interval:间隔时间，即定时器秒数。
    +   function:执行的函数
    +   args:传入function的参数，如果None，则会传入空的tuple
    +   kwargs:传入function的关键字参数，字典
+   cancel()停止一个计时器
####    栅栏对象：threading.Barrier
+   栅栏对象用于一个固定数量的线程，而这些线程需要等待彼此的情况。这些线程中的每个线程都会尝试调用wait()方法，然后所有线程都被同事释放。
+   threading.Barrier(parties,action=None,timeout=None)
    +   parties:指定需要创建的栅栏对象的线程数
    +   action：一个可调用对象，当所有线程都被释放时，在释放前，一个线程随机会调用这个对象。
    +   timeout:设置wait()方法的超时时间
    +   wait(timeout=None)：通过栅栏。当所有线程都调用了这个方法，则所有线程会被同时释放。如果提供了timeout参数，那么此参数是优先于初始化方法中的timeout参数的。返回值为range(parties)中的一个整数，每个线程的返回值都不同。如果提供了action参数，那么在所有线程释放前，其中一个线程（随机）会调用这个action参数对象，并且如果这个action调用发生了异常，则栅栏对象将进入破损状态。如果wait()方法发生了超时事件，那么栅栏对象也将进入破损状态。如果栅栏对象进入破损状态或者重置栅栏对象时仍有线程在等待释放，则会报BrokenBarrierError异常。
    +   reset()：将一个栅栏对象重置为默认的初始态。如果此时有任何线程正在等待释放，那么将会报BrokenBarrierError异常。如果barrier中有线程的状态是未知的，那么可能需要外部的某种同步来确保线程已被释放。如果栅栏对象已经破损，那么最好是丢弃它并重新创建一个新的栅栏对象。
    +   abort()：使栅栏对象进入破损状态。这将导致所有已经调用和未调用的wait()方法引发BrokenBarrierError异常。比如，需要放弃一个线程，但又不想引发死锁的情况，就可以调用这个方法。一个更好的办法是提供一个合理的timeout参数值，来自动避免某个线程出错。
    +   parties：通过栅栏的线程数量。
    +   n_waiting：在栅栏中正在等待的线程数量。
    +   broken：如果栅栏对象为破损状态则返回True。
#### 概念的再理解
+   GIL 是 Python 解释器正确运行的保证，Python 语言本身没有提供任何机制访问它。但在特定场合，我们仍有办法降低它对效率的影响。
+   多线程与多进程的理解
    +   **进程ID**：多线程的主进程和它的子线程的进程ID，即os.getpid()，都是相同的，都是主进程的进程ID。多进程则是主进程和它的子进程都有各自的进程ID，都不相同。
    +   **共享数据**：多线程可以共享主进程内的数据，但是多进程用的都是各自的数据，无法共享。
    +   **主线程**：由Python解释器运行主py时，也就是开启了一个Python进程，而这个py是这个进程内的一个线程，不过不同于其他线程，它是主线程，同时这个进程内还有其他的比如垃圾回收等解释器级别的线程，所以进程就等于主线程这种理解是有误的。
    +   **CPU多核利用**：Python解释器的线程只能在CPU单核上运行，开销小，但是这也是缺点，因为没有利用CPU多核的特点。Python的多进程是可以利用多个CPU核心的，但也有其他语言的多线程是可以利用多核的。
    +   **单核与多核**：一个CPU的主要作用是用来做计算的，多个CPU核心如果都用来做计算，那么效率肯定会提高很多，但是对于IO来说，多个CPU核心也没有太大用处，因为没有输入，后面的动作也无法执行。所以如果一个程序是计算密集型的，那么就该利用多核的优势（比如使用Python的多进程），如果是IO密集型的，那么使用单核的多线程就完全够了。
    +   **线程或进程间的切换**：线程间的切换是要快于进程间的切换的。
    +   **死锁**：指的是两个或两个以上的线程或进程在请求锁的时候形成了互相等待阻塞的情况，导致这些线程或进程无法继续执行下去，这时候称系统处于死锁状态或者系统产生了死锁，这些线程或进程就称为死锁线程或死锁进程。解决死锁的办法可以使用递归锁，即threading.RLock，然后线程或进程就可以随意请求和释放锁了，而不用担心别的线程或进程也在请求锁而产生死锁的情况。

    +   **信号量与进程池**：进程池Pool(n)只能是“池”中的n个进程运行，不能有新的进程，信号量只要保证最大线程数就行，而不是只有这几个线程，旧的线程运行结束，就可以继续来新的线程。
